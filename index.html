<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=AW-17743248817"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'AW-17743248817');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Albus Technologies - Coming Soon</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        ::selection {
            background-color: #D9F827;
            color: #000;
        }

        body {
            font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            background-color: #ffffff;
            color: #111827;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }

        .logo {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            color: #111827;
            text-transform: uppercase;
        }

        .main-content {
            text-align: center;
            max-width: 48rem;
        }

        h1 {
            font-size: 4.5rem;
            font-weight: 800;
            line-height: 1.1;
            color: #111827;
            margin-bottom: 1.5rem;
            letter-spacing: -0.025em;
        }

        .subtitle {
            font-size: 1.25rem;
            line-height: 1.75rem;
            color: #4b5563;
            font-weight: 400;
        }

        .accent {
            color: #D9F827;
            background-color: #000;
            padding: 0.125rem 0.5rem;
            display: inline-block;
            box-shadow: 4px 4px 0px 0px rgba(0, 0, 0, 1);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .logo {
                font-size: 1.125rem;
                top: 1.5rem;
            }

            h1 {
                font-size: 3rem;
            }

            .subtitle {
                font-size: 1.125rem;
            }
        }

        @media (max-width: 640px) {
            h1 {
                font-size: 2.25rem;
            }
        }
    </style>
    <!-- Cloudflare Web Analytics -->
    <script defer src='https://static.cloudflareinsights.com/beacon.min.js'
        data-cf-beacon='{"token": "88cc4528878147f4a2d1f3762d917710"}'></script>
    <!-- End Cloudflare Web Analytics -->
</head>

<body>
    <div class="logo">Albus</div>

    <div class="main-content">
        <h1>Coming <span class="accent">Soon</span></h1>
        <div class="subtitle">Something magical is brewing</div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const init = () => {
            const scene = new THREE.Scene();
            // White background to match the clean aesthetic
            scene.background = new THREE.Color(0xffffff);
            // Add some fog for depth
            scene.fog = new THREE.FogExp2(0xffffff, 0.002);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;
            camera.position.y = 10;
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Add canvas to the background
            const canvas = renderer.domElement;
            canvas.style.position = 'fixed';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.zIndex = '-1';
            document.body.appendChild(canvas);

            // Particles
            const geometry = new THREE.BufferGeometry();
            const count = 2000;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const originalY = new Float32Array(count);

            const color1 = new THREE.Color(0xbbbbbb); // Neutral Gray
            const color2 = new THREE.Color(0xD9F827); // Brand Neon Yellow

            for (let i = 0; i < count; i++) {
                const x = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 100;
                const y = 0;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                originalY[i] = y;

                // Initialize with gray
                colors[i * 3] = color1.r;
                colors[i * 3 + 1] = color1.g;
                colors[i * 3 + 2] = color1.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Mouse interaction
            const mouse = new THREE.Vector2();
            const target = new THREE.Vector2();
            const windowHalfX = window.innerWidth / 2;
            const windowHalfY = window.innerHeight / 2;

            document.addEventListener('mousemove', (event) => {
                mouse.x = (event.clientX - windowHalfX);
                mouse.y = (event.clientY - windowHalfY);
            });

            const clock = new THREE.Clock();

            const animate = () => {
                requestAnimationFrame(animate);

                const time = clock.getElapsedTime();
                const positions = particles.geometry.attributes.position.array;
                const colors = particles.geometry.attributes.color.array;

                // Smooth mouse movement
                target.x += (mouse.x - target.x) * 0.05;
                target.y += (mouse.y - target.y) * 0.05;

                // Rotate entire system slightly based on mouse
                particles.rotation.y = target.x * 0.0001;
                particles.rotation.x = target.y * 0.0001;

                for (let i = 0; i < count; i++) {
                    const x = positions[i * 3];
                    const z = positions[i * 3 + 2];

                    // Wave effect
                    const waveY = Math.sin(x * 0.1 + time) * Math.cos(z * 0.1 + time) * 2;

                    // Mouse interaction distance
                    // Project 3D point to 2D screen space to check distance from mouse
                    // Simplified: Check distance from center modified by mouse target
                    const dist = Math.sqrt(
                        Math.pow(x - target.x * 0.05, 2) +
                        Math.pow(z - target.y * 0.05, 2)
                    );

                    // React to proximity
                    let hoverEffect = 0;
                    if (dist < 15) {
                        hoverEffect = (15 - dist) / 15; // 0 to 1
                    }

                    // Update Y position: Wave + Hover Lift
                    positions[i * 3 + 1] = originalY[i] + waveY + (hoverEffect * 5);

                    // Update Color: Mix between Gray and Neon Yellow based on hover
                    const mixedColor = color1.clone().lerp(color2, hoverEffect);

                    colors[i * 3] = mixedColor.r;
                    colors[i * 3 + 1] = mixedColor.g;
                    colors[i * 3 + 2] = mixedColor.b;
                }

                particles.geometry.attributes.position.needsUpdate = true;
                particles.geometry.attributes.color.needsUpdate = true;

                renderer.render(scene, camera);
            };

            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        };

        init();
    </script>
</body>

</html>